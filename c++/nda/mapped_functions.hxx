/**
 * @file
 * @brief Provides lazy, coefficient-wise array operations of standard mathematical functions together with overloads
 * for nda::Scalar types.
 */

#pragma once

#include "./concepts.hpp"
#include "./map.hpp"
#include "./mapped_functions.hpp"
#include "./traits.hpp"

#include <cmath>
#include <complex>
#include <utility>

/*
   File is generated by vim.
   To regenerate the file,
     1- load the vim function by (or add this to your .vim ?)
        :source vimexpand.vim
     2- call it
        :call VimExpandSimple()


   It is better than C macro, it gives a cleaner code
   (for error messages, no preproc, doc generation : otherwise no doc string ...)

  ----  normal mapping -------

  VIMEXPAND abs imag floor
  /// \brief Function @ for nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return A lazy nda::expr_call object (nda::Array) or the result of `std::@` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto @(A &&a)  {
    return nda::map(
       [](auto const &x) {
         using std::@;
         return @(x);
       })(std::forward<A>(a));
  }

 ---------  same, no using std::-------

  VIMEXPAND real abs2 isnan
  /// \brief Function @ for nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type..
  /// \param a nda::ArrayOrScalar object.
  /// \return A lazy nda::expr_call object (nda::Array) or the result of `nda::detail::@` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto @(A &&a) {
    return nda::map(
       [](auto const &x) {return detail::@(x); })(std::forward<A>(a));
  }

 ---------  mapping with matrix excluded -------

  VIMEXPAND exp cos sin tan cosh sinh tanh acos asin atan log sqrt
  /// \brief Function @ for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::@` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto @(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::@;
         return @(x);
       })(std::forward<A>(a));
  }

*/

namespace nda {

  /**
   * @addtogroup av_math
   * @{
   */

  // --- VIMEXPAND_START  --DO NOT EDIT BELOW --


  /// \brief Function abs for nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return A lazy nda::expr_call object (nda::Array) or the result of `std::abs` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto abs(A &&a)  {
    return nda::map(
       [](auto const &x) {
         using std::abs;
         return abs(x);
       })(std::forward<A>(a));
  }

  /// \brief Function imag for nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return A lazy nda::expr_call object (nda::Array) or the result of `std::imag` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto imag(A &&a)  {
    return nda::map(
       [](auto const &x) {
         using std::imag;
         return imag(x);
       })(std::forward<A>(a));
  }

  /// \brief Function floor for nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return A lazy nda::expr_call object (nda::Array) or the result of `std::floor` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto floor(A &&a)  {
    return nda::map(
       [](auto const &x) {
         using std::floor;
         return floor(x);
       })(std::forward<A>(a));
  }

  /// \brief Function real for nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type..
  /// \param a nda::ArrayOrScalar object.
  /// \return A lazy nda::expr_call object (nda::Array) or the result of `nda::detail::real` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto real(A &&a) {
    return nda::map(
       [](auto const &x) {return detail::real(x); })(std::forward<A>(a));
  }

  /// \brief Function abs2 for nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type..
  /// \param a nda::ArrayOrScalar object.
  /// \return A lazy nda::expr_call object (nda::Array) or the result of `nda::detail::abs2` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto abs2(A &&a) {
    return nda::map(
       [](auto const &x) {return detail::abs2(x); })(std::forward<A>(a));
  }

  /// \brief Function isnan for nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type..
  /// \param a nda::ArrayOrScalar object.
  /// \return A lazy nda::expr_call object (nda::Array) or the result of `nda::detail::isnan` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto isnan(A &&a) {
    return nda::map(
       [](auto const &x) {return detail::isnan(x); })(std::forward<A>(a));
  }

  /// \brief Function exp for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::exp` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto exp(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::exp;
         return exp(x);
       })(std::forward<A>(a));
  }

  /// \brief Function cos for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::cos` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto cos(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::cos;
         return cos(x);
       })(std::forward<A>(a));
  }

  /// \brief Function sin for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::sin` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto sin(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::sin;
         return sin(x);
       })(std::forward<A>(a));
  }

  /// \brief Function tan for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::tan` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto tan(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::tan;
         return tan(x);
       })(std::forward<A>(a));
  }

  /// \brief Function cosh for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::cosh` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto cosh(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::cosh;
         return cosh(x);
       })(std::forward<A>(a));
  }

  /// \brief Function sinh for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::sinh` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto sinh(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::sinh;
         return sinh(x);
       })(std::forward<A>(a));
  }

  /// \brief Function tanh for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::tanh` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto tanh(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::tanh;
         return tanh(x);
       })(std::forward<A>(a));
  }

  /// \brief Function acos for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::acos` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto acos(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::acos;
         return acos(x);
       })(std::forward<A>(a));
  }

  /// \brief Function asin for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::asin` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto asin(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::asin;
         return asin(x);
       })(std::forward<A>(a));
  }

  /// \brief Function atan for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::atan` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto atan(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::atan;
         return atan(x);
       })(std::forward<A>(a));
  }

  /// \brief Function log for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::log` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto log(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::log;
         return log(x);
       })(std::forward<A>(a));
  }

  /// \brief Function sqrt for non-matrix nda::ArrayOrScalar types (lazy and coefficient-wise for nda::Array types).
  ///
  /// \tparam A nda::ArrayOrScalar type.
  /// \param a nda::ArrayOrScalar object.
  /// \return  A lazy nda::expr_call object (nda::Array) or the result of `std::sqrt` applied to the object (nda::Scalar).
  template <ArrayOrScalar A>
  auto sqrt(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::sqrt;
         return sqrt(x);
       })(std::forward<A>(a));
  }

  /** @} */

}
